def get_neighbors(state):
    neighbors = []
    blank = state.index(0)
    x, y = divmod(blank, 3)

    moves = [(-1,0), (1,0), (0,-1), (0,1)]  # up, down, left, right
    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_blank = nx*3 + ny
            new_state = list(state)
            new_state[blank], new_state[new_blank] = new_state[new_blank], new_state[blank]
            neighbors.append(tuple(new_state))
    return neighbors

# Depth Limited Search (recursive)
def depth_limited_search(state, goal, limit, path, visited):
    if state == goal:
        return path
    if limit == 0:
        return None

    visited.add(state)
    for neighbor in get_neighbors(state):
        if neighbor not in visited:
            result = depth_limited_search(neighbor, goal, limit - 1, path + [neighbor], visited)
            if result is not None:
                return result
    return None

# Iterative Deepening Search
def iterative_deepening_search(initial, goal):
    depth = 0
    while True:
        visited = set()
        result = depth_limited_search(initial, goal, depth, [initial], visited)
        if result is not None:
            return result, depth
        depth += 1

# Print puzzle in 3x3 grid
def print_state(state):
    for i in range(0, 9, 3):
        print(state[i:i+3])
    print()

# Main
if __name__ == "__main__":
    print("Enter initial state (9 numbers, use 0 for blank):")
    initial = tuple(map(int, input().split()))
    print("Enter goal state (9 numbers, use 0 for blank):")
    goal = tuple(map(int, input().split()))

    path, depth = iterative_deepening_search(initial, goal)

    print("\nSolution found at depth:", depth)
    print("Number of moves:", len(path)-1)
    print("\nSteps:")
    for step in path:
        print_state(step)
